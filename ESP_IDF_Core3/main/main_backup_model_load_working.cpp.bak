#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <cmath>
#include "esp_log.h"
#include "esp_heap_caps.h"
#include "esp_vfs_fat.h"
#include "bsp/m5stack_core_s3.h"
#include "lvgl.h"
#include "jpeg_decoder.h"
#include "dl_model_base.hpp"

using namespace dl;

static const char *TAG = "UHD_DETECTION";

// モデル定数
const int INPUT_SIZE = 64;
const int GRID_SIZE = 8;
const int NUM_ANCHORS = 8;
const int NUM_CLASSES = 80;

// 検出結果
struct Detection {
    float x, y, w, h;     // 正規化座標 [0, 1]
    int class_id;
    float confidence;
    const char* label;
};

// COCO クラスラベル（簡略版）
const char* COCO_CLASSES[] = {
    "person", "bicycle", "car", "motorcycle", "airplane", "bus", "train", "truck", "boat",
    "traffic light", "fire hydrant", "stop sign", "parking meter", "bench", "bird", "cat",
    "dog", "horse", "sheep", "cow", "elephant", "bear", "zebra", "giraffe", "backpack",
    "umbrella", "handbag", "tie", "suitcase", "frisbee", "skis", "snowboard", "sports ball",
    "kite", "baseball bat", "baseball glove", "skateboard", "surfboard", "tennis racket",
    "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple",
    "sandwich", "orange", "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair",
    "couch", "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "mouse",
    "remote", "keyboard", "cell phone", "microwave", "oven", "toaster", "sink",
    "refrigerator", "book", "clock", "vase", "scissors", "teddy bear", "hair drier",
    "toothbrush"
};

// モデル定数（SDカードから読み込み）
struct ModelConstants {
    float anchors[NUM_ANCHORS][2];
    float wh_scale[NUM_ANCHORS][2];
};

// 画像のリサイズ（バイリニア補間）
void resize_rgb565_to_rgb888(uint16_t* src, int src_w, int src_h, 
                             uint8_t* dst, int dst_w, int dst_h)
{
    float x_ratio = (float)src_w / dst_w;
    float y_ratio = (float)src_h / dst_h;
    
    for (int y = 0; y < dst_h; y++) {
        for (int x = 0; x < dst_w; x++) {
            float px = x * x_ratio;
            float py = y * y_ratio;
            int ix = (int)px;
            int iy = (int)py;
            
            if (ix >= src_w - 1) ix = src_w - 2;
            if (iy >= src_h - 1) iy = src_h - 2;
            
            // RGB565からRGB888へ変換（簡易版：最近傍）
            uint16_t pixel = src[iy * src_w + ix];
            uint8_t r = ((pixel >> 11) & 0x1F) << 3;
            uint8_t g = ((pixel >> 5) & 0x3F) << 2;
            uint8_t b = (pixel & 0x1F) << 3;
            
            int dst_idx = (y * dst_w + x) * 3;
            dst[dst_idx + 0] = r;
            dst[dst_idx + 1] = g;
            dst[dst_idx + 2] = b;
        }
    }
}

// RGB888を正規化してfloatに変換
void normalize_rgb888_to_float(uint8_t* src, float* dst, int size)
{
    int pixel_count = size * size;
    for (int c = 0; c < 3; c++) {
        for (int i = 0; i < pixel_count; i++) {
            dst[c * pixel_count + i] = src[i * 3 + c] / 255.0f;
        }
    }
}

// Sigmoid関数
float sigmoid(float x) {
    return 1.0f / (1.0f + expf(-x));
}

// IoU計算
float calculate_iou(Detection &a, Detection &b) {
    float x1 = fmaxf(a.x - a.w/2, b.x - b.w/2);
    float y1 = fmaxf(a.y - a.h/2, b.y - b.h/2);
    float x2 = fminf(a.x + a.w/2, b.x + b.w/2);
    float y2 = fminf(a.y + a.h/2, b.y + b.h/2);
    
    float intersection = fmaxf(0.0f, x2 - x1) * fmaxf(0.0f, y2 - y1);
    float area_a = a.w * a.h;
    float area_b = b.w * b.h;
    float union_area = area_a + area_b - intersection;
    
    return (union_area > 0) ? (intersection / union_area) : 0.0f;
}

// NMS（Non-Maximum Suppression）
std::vector<Detection> apply_nms(std::vector<Detection> &detections, float iou_threshold) {
    std::vector<Detection> result;
    
    // 信頼度で降順ソート
    std::sort(detections.begin(), detections.end(), 
              [](Detection &a, Detection &b) { return a.confidence > b.confidence; });
    
    std::vector<bool> suppressed(detections.size(), false);
    
    for (size_t i = 0; i < detections.size(); i++) {
        if (suppressed[i]) continue;
        result.push_back(detections[i]);
        
        for (size_t j = i + 1; j < detections.size(); j++) {
            if (suppressed[j]) continue;
            if (detections[i].class_id == detections[j].class_id) {
                float iou = calculate_iou(detections[i], detections[j]);
                if (iou > iou_threshold) {
                    suppressed[j] = true;
                }
            }
        }
    }
    
    return result;
}

extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "=== UHD Object Detection with AI ===");

    // 1. LCD 初期化
    lv_display_t *display = bsp_display_start();
    if (!display) {
        ESP_LOGE(TAG, "Display init failed");
        return;
    }

    bsp_display_lock(0);
    lv_obj_set_style_bg_color(lv_screen_active(), lv_color_black(), 0);
    bsp_display_unlock();

    // 2. SDカードマウント
    ESP_LOGI(TAG, "Mounting SD card...");
    if (bsp_sdcard_mount() != ESP_OK) {
        ESP_LOGE(TAG, "SD mount failed!");
        return;
    }

    // 3. モデル定数をロード
    ESP_LOGI(TAG, "Loading model constants...");
    ModelConstants consts;
    FILE* f = fopen("/sdcard/model.bin", "rb");
    if (!f) {
        ESP_LOGE(TAG, "Failed to open model.bin!");
        return;
    }
    fread(consts.anchors, sizeof(float), NUM_ANCHORS * 2, f);
    fread(consts.wh_scale, sizeof(float), NUM_ANCHORS * 2, f);
    fclose(f);
    ESP_LOGI(TAG, "Model constants loaded");

    // 4. ESP-DLモデルをロード
    ESP_LOGI(TAG, "Loading ESP-DL model...");
    Model *model = new Model("/sdcard/model.espdl", fbs::MODEL_LOCATION_IN_SDCARD);
    if (!model) {
        ESP_LOGE(TAG, "Failed to load model!");
        return;
    }
    ESP_LOGI(TAG, "Model loaded successfully");

    // 5. JPEG画像をロード
    ESP_LOGI(TAG, "Loading image...");
    f = fopen("/sdcard/image.jpg", "rb");
    if (!f) {
        ESP_LOGE(TAG, "Cannot open image.jpg!");
        return;
    }

    fseek(f, 0, SEEK_END);
    size_t jpg_size = ftell(f);
    fseek(f, 0, SEEK_SET);

    uint8_t *jpg_buf = (uint8_t *)malloc(jpg_size);
    if (!jpg_buf) {
        ESP_LOGE(TAG, "Failed to allocate memory for JPEG");
        fclose(f);
        return;
    }

    fread(jpg_buf, 1, jpg_size, f);
    fclose(f);
    ESP_LOGI(TAG, "JPEG file size: %u bytes", jpg_size);

    // 6. JPEGデコード
    size_t out_size = 320 * 240 * 2;
    uint8_t *rgb565_buf = (uint8_t *)heap_caps_malloc(out_size, MALLOC_CAP_SPIRAM);
    if (!rgb565_buf) {
        ESP_LOGE(TAG, "Failed to allocate RGB565 buffer");
        free(jpg_buf);
        return;
    }

    esp_jpeg_image_cfg_t jpeg_cfg = {
        .indata = jpg_buf,
        .indata_size = (uint32_t)jpg_size,
        .outbuf = rgb565_buf,
        .outbuf_size = (uint32_t)out_size,
        .out_format = JPEG_IMAGE_FORMAT_RGB565,
        .out_scale = JPEG_IMAGE_SCALE_0,
        .flags = {.swap_color_bytes = 0},
        .advanced = {},
        .priv = {},
    };

    esp_jpeg_image_output_t jpeg_out = {};
    esp_err_t ret = esp_jpeg_decode(&jpeg_cfg, &jpeg_out);
    free(jpg_buf);

    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "JPEG decode failed");
        heap_caps_free(rgb565_buf);
        return;
    }

    ESP_LOGI(TAG, "JPEG decoded: %dx%d", jpeg_out.width, jpeg_out.height);

    // 7. 画像を64x64にリサイズ＆正規化
    ESP_LOGI(TAG, "Preprocessing image for inference...");
    uint8_t *rgb888_64x64 = (uint8_t *)heap_caps_malloc(INPUT_SIZE * INPUT_SIZE * 3, MALLOC_CAP_SPIRAM);
    float *input_tensor = (float *)heap_caps_malloc(INPUT_SIZE * INPUT_SIZE * 3 * sizeof(float), MALLOC_CAP_SPIRAM);
    
    if (!rgb888_64x64 || !input_tensor) {
        ESP_LOGE(TAG, "Failed to allocate preprocessing buffers");
        heap_caps_free(rgb565_buf);
        if (rgb888_64x64) heap_caps_free(rgb888_64x64);
        if (input_tensor) heap_caps_free(input_tensor);
        return;
    }

    resize_rgb565_to_rgb888((uint16_t*)rgb565_buf, jpeg_out.width, jpeg_out.height,
                           rgb888_64x64, INPUT_SIZE, INPUT_SIZE);
    normalize_rgb888_to_float(rgb888_64x64, input_tensor, INPUT_SIZE);
    heap_caps_free(rgb888_64x64);
    
    ESP_LOGI(TAG, "Image preprocessed to 64x64");

    // 8. 推論実行（TODO: ESP-DL APIを正しく実装）
    ESP_LOGI(TAG, "Inference execution - PLACEHOLDER");
    ESP_LOGI(TAG, "Model loaded successfully, ready for inference");
    ESP_LOGI(TAG, "Input tensor prepared: 64x64x3 float32");
    
    // 推論時間の測定（プレースホルダー）
    int64_t inference_time = 50;  // 仮の値
    
    // 9. 出力をデコード（ダミー検出結果）
    ESP_LOGI(TAG, "Using dummy detections for testing...");
    
    std::vector<Detection> detections;
    Detection det1 = {0.25f, 0.25f, 0.3f, 0.3f, 0, 0.85f, "person"};
    Detection det2 = {0.65f, 0.35f, 0.25f, 0.4f, 2, 0.72f, "car"};
    detections.push_back(det1);
    detections.push_back(det2);
    
    ESP_LOGI(TAG, "Found %d detections (dummy)", detections.size());

    // 10. 画像を表示
    bsp_display_lock(0);

    lv_obj_t *canvas = lv_canvas_create(lv_screen_active());
    lv_canvas_set_buffer(canvas, rgb565_buf, jpeg_out.width, jpeg_out.height, 
                        LV_COLOR_FORMAT_RGB565);
    lv_obj_center(canvas);

    // 11. バウンディングボックスを描画
    int img_offset_x = (320 - jpeg_out.width) / 2;
    int img_offset_y = (240 - jpeg_out.height) / 2;
    
    lv_color_t colors[] = {
        lv_color_hex(0x00FF00),  // 緑
        lv_color_hex(0xFF0000),  // 赤
        lv_color_hex(0x00FFFF),  // シアン
    };

    for (size_t i = 0; i < detections.size(); i++) {
        Detection &det = detections[i];
        lv_color_t color = colors[i % 3];
        
        // 正規化座標をピクセル座標に変換
        int x = (int)(det.x * jpeg_out.width) - det.w * jpeg_out.width / 2;
        int y = (int)(det.y * jpeg_out.height) - det.h * jpeg_out.height / 2;
        int w = (int)(det.w * jpeg_out.width);
        int h = (int)(det.h * jpeg_out.height);
        
        // 矩形描画
        lv_obj_t *rect = lv_obj_create(lv_screen_active());
        lv_obj_set_size(rect, w, h);
        lv_obj_set_pos(rect, x + img_offset_x, y + img_offset_y);
        lv_obj_set_style_bg_opa(rect, LV_OPA_TRANSP, 0);
        lv_obj_set_style_border_color(rect, color, 0);
        lv_obj_set_style_border_width(rect, 3, 0);
        lv_obj_set_style_radius(rect, 0, 0);
        
        // ラベル描画
        lv_obj_t *label = lv_label_create(lv_screen_active());
        char text[64];
        snprintf(text, sizeof(text), "%s %.0f%%", det.label, det.confidence * 100);
        lv_label_set_text(label, text);
        lv_obj_set_style_text_color(label, color, 0);
        lv_obj_set_style_bg_color(label, lv_color_black(), 0);
        lv_obj_set_style_bg_opa(label, LV_OPA_80, 0);
        lv_obj_set_style_pad_all(label, 3, 0);
        lv_obj_set_pos(label, x + img_offset_x, y - 22 + img_offset_y);
        
        ESP_LOGI(TAG, "Detected: %s (%.2f) at (%d,%d,%d,%d)", 
                 det.label, det.confidence, x, y, w, h);
    }

    bsp_display_unlock();

    ESP_LOGI(TAG, "Detection complete! Inference: %lld ms", inference_time);

    // クリーンアップ
    heap_caps_free(input_tensor);
    delete model;

    // メインループ
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
